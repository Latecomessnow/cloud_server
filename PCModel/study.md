# 生产者与消费者模型

生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。

生产者和消费者彼此之间不直接通讯，而通过这个容器来通讯，所以生产者生产完数据之后不用等待消费者处理，直接将生产的数据放到这个容器当中，消费者也不用找生产者要数据，而是直接从这个容器里取数据，这个容器就相当于一个缓冲区，平衡了生产者和消费者的处理能力，这个容器实际上就是用来给生产者和消费者解耦的。

### 生产者消费者模型是多线程同步与互斥的一个经典场景，其特点如下：

1. 三种关系： 生产者和生产者（互斥关系）、消费者和消费者（互斥关系）、生产者和消费者（互斥关系、同步关系）。

2. 两种角色： 生产者和消费者。（通常由进程或线程承担）

3. 一个交易场所： 通常指的是内存中的一段缓冲区。（可以自己通过某种方式组织起来）

注意： 互斥关系保证的是数据的正确性，而同步关系是为了让多线程之间协同起来。

- 在多线程编程中，阻塞队列（Blocking Queue）是一种常用于实现生产者和消费者模型的数据结构。

其与普通的队列的区别在于：

当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中放入了元素。

当队列满时，往队列里存放元素的操作会被阻塞，直到有元素从队列中取出。

///////////////////////////////////////////////////////////////////

判断是否满足生产消费条件时不能用if，而应该用while：

1. pthread_cond_wait函数是让当前执行流进行等待的函数，是函数就意味着有可能调用失败，调用失败后该执行流就会继续往后执行。

2. 其次，在多消费者的情况下，当生产者生产了一个数据后如果使用pthread_cond_broadcast函数唤醒消费者，就会一次性唤醒多个消费者，但待消费的数据只有一个，此时其他消费者就被伪唤醒了。

3. 为了避免出现上述情况，我们就要让线程被唤醒后再次进行判断，确认是否真的满足生产消费条件，因此这里必须要用while进行判断。