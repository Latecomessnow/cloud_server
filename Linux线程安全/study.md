## Linux线程互斥

### 进程线程间的互斥相关背景概念

1. 临界资源： 多线程执行流共享的资源叫做临界资源。

2. 临界区： 每个线程内部，访问临界资源的代码，就叫做临界区。

3. 互斥： 任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用。

4. 原子性： 不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成。


在多线程情况下，如果这多个执行流都自顾自的对临界资源进行操作，那么此时就可能导致数据不一致的问题。解决该问题的方案就叫做互斥，互斥的作用就是，保证在任何时候有且只有一个执行流进入临界区对临界资源进行访问。

// 抢票不加锁存在的问题

一开始临界资源ticket = 1000;

1. thread-1线程先被CPU调度，thread-1线程刚刚被调度就被切走了，那么thread-1被切走时
还要带走它的上下文数据，此时thread-1上下文数据中的ticket就还是1000

2. thread-1线程被切走后，thread-2线程立马就被调度，由于thread-1线程刚刚被调度就被切走了
只是执行了--操作的第一步，并没有把--之后的数据写回到内存中，所以thread-2中看到的ticket
还是1000，thread-2执行了100次--操作后，ticket变为900，但还未写回到内存中，thread-2线程
就被切走了，所以内存中的ticket还是1000

3. thread-2被切走后，thread-1又被调度回来了，此时thread-1上下文数据ticket=1000也会被
加载回CPU内，执行--操作后写回到内存中，所以此时内存中的ticket就是999
但是我们要知道thread-1执行了1次--操作，thread-2执行了100次--操作，而剩余的票数却是999
这就是有问题的！！！

++、-- 操作都不是原子的

////////////////////////////////

要解决上述抢票系统的问题，需要做到三点：

1. 代码必须有互斥行为：当代码进入临界区执行时，不允许其他线程进入该临界区。

2. 如果多个线程同时要求执行临界区的代码，并且此时临界区没有线程在执行，那么只能允许一个线程进入该临界区。

3. 如果线程不在临界区中执行，那么该线程不能阻止其他线程进入临界区。
要做到这三点，本质上就是需要一把锁，Linux上提供的这把锁叫互斥量。


pthreda_mutex_t mtx // 互斥量

// 对互斥量进行加锁操作

```c++
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
```
mutex：需要初始化的互斥量。
attr：初始化互斥量的属性，一般设置为NULL即可。