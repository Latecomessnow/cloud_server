2^12 bytes--->4KB

2^32 bytes--->4GB

物理内存中以4KB作为一个页框分配内存

磁盘上的程序也是被划分成一个个4KB大小的页帧的，当内存和磁盘进行数据交换时也就是以4KB大小为单位进行加载和保存的。

### 线程的缺点

性能损失： 一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。

健壮性降低： 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说，线程之间是缺乏保护的。

缺乏访问控制： 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。

编程难度提高： 编写与调试一个多线程程序比单线程程序困难得多。

### 线程异常

单个线程如果出现除零、野指针等问题导致线程崩溃，进程也会随着崩溃。

线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出。

### 线程终止

如果需要只终止某个线程而不是终止整个进程，可以有三种方法：

1. 从线程函数return。
2. 线程可以自己调用pthread_exit函数终止自己。
3. 一个线程可以调用pthread_cancel函数终止同一进程中的另一个线程。

### 分离线程
默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而造成内存泄漏。

但如果我们不关心线程的返回值，join也是一种负担，此时我们可以将该线程进行分离，后续当线程退出时就会自动释放线程资源。

一个线程如果被分离了，这个线程依旧要使用该进程的资源，依旧在该进程内运行，甚至这个线程崩溃了一定会影响其他线程，只不过这个线程退出时不再需要主线程去join了，当这个线程退出时系统会自动回收该线程所对应的资源。

可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离。

joinable和分离是冲突的，一个线程不能既是joinable又是分离的。

```c++
int pthread_detach(pthread_t thread);
```

我们说每个线程都有自己私有的栈，其中主线程采用的栈是进程地址空间中原生的栈，而其余线程采用的栈就是在共享区中开辟的。除此之外，每个线程都有自己的struct pthread，当中包含了对应线程的各种属性；每个线程还有自己的线程局部存储，当中包含了对应线程被切换时的上下文数据。

每一个新线程在共享区都有这样一块区域对其进行描述，因此我们要找到一个用户级线程只需要找到该线程内存块的起始地址，然后就可以获取到该线程的各种信息。

